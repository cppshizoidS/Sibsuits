
# Гайд по Git для начинающих

## Введение

[Git](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) - это распределенная система управления версиями, которая позволяет отслеживать изменения в коде и вести совместную разработку.
### Основные понятия:
-   Репозиторий(Repository) - место, хранится ваш проект и все его коммиты
-   Коммит(Commit) - запись изменений(снимков файлов) в проекте. У каждого коммита есть свой уникальный идентификатор
-   Ветка(Branch) - это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита. Коммиты в разных ветках не влияют на коммиты в другой и поэтому если вы закоммитили в ветку с названием lab1 этот коммит не будет отображаться в ветке master

### Установка и настройка Git на Debian/Ubuntu

1.  Откройте терминал
2.  Установите git командой: ```sudo apt install git```
3.  После установки проверьте версию git чтобы убедиться что гит установлен: командой ```git --version```
4.  Основные настройки: 
    ```git config --global user.name "Ваше Имя"```
	```git config --global user.email "ваша@почта.com"```
	
	
### Прокидывание ключей

* Шаг 1 Генерация ssh ключа

Откройте терминал (или командную строку) на вашем компьютере.
Введите следующую команду, чтобы начать процесс генерации SSH-ключа. Замените <ваш_email> на свой email от гитлаба.

```sh
ssh-keygen  -t  rsa  -b  4096  -C  "<ваш_email>"
Процесс  генерации  запросит  вас  ввести  место  для  сохранения  ключа.  Нажмите  Enter,  чтобы  использовать  место  по  умолчанию (обычно ~/.ssh/id_rsa).
```
Введите email от гитлаба ip314sNN@csc.sibsutis.ru NN-номер в вашем гиталабе

Ключ будет сгенерирован. Вы увидите сообщение о том, что ключ успешно создан.



* Шаг 2 Добавление SSH-ключа на GitLab

Сначала скопируйте ваш открытый ключ, который обычно находится в файле ~/.ssh/id_rsa.pub. Вы можете использовать команду cat или открыть файл в текстовом редакторе.

```sh
cat  ~/.ssh/id_rsa.pub
```
Копируйте вывод ключа
  
Зайдите в свой аккаунт на GitLab.
В правом верхнем углу страницы, нажмите на свой аватар и выберите "Settings".
В меню слева выберите "SSH Keys".
Вставьте скопированный ранее открытый ключ в поле "Key".
Дайте ключу описательное имя, чтобы вы могли легко определить его (например, "Мой компьютер").

Нажмите "Add key", чтобы сохранить ключ.

Если все настроено правильно, вы увидите сообщение подтверждения.

### Работа с коммитами
-    Перейдите в папку где нужно создать репозиторий
-   Создать репозиторий ```git init```
-   Посмотреть изменения в проекте(!!!! локально): ```git status```
-   Добавить файлы для коммита: ```git add файл.txt```(реальное имя файла и его расширение например для си в лабе: ```git add main.c```)
-   Посмотреть изменения в файле: ```git diff``` (git diff отображает изменения между вашим рабочим каталогом и последним коммитом)

Например вы добавили функцию main() при вводе команды ```git diff``` вы увидете    что-то подобное:

![](https://lh7-us.googleusercontent.com/xCB6-6jnX-YBgYQ2QKlcH6mhpWsfDsmXb_4RJlJnwMoYVlXwacTduvOH9TvA__YTKYtDgqjXV4U1GLmqYnqzVhNwqX3EkC06Ol9GEMjgmTKU2MUQRQTaMNAjhO-pg9HAKDkC2rHKMTmqYB3b2WjUhHw)

-   Если использовать ```git diff --staged``` вы увидите что уже проиндексированои что попадет в коммит

-   Сделать коммит: ```git commit <название файла(в нашей лабе файл называется main.c>-m "тут пишется сообщение описывающее коммит например: добавил функцию aboba()"```


-   Посмотреть истории изменений(коммитов):  ```git log```
![](https://lh7-us.googleusercontent.com/ysHjHOdZYS-Kl58aQ2A9HWnJyzvxffO9X2ke20saRQT18Vg550D_s1Pyb99v4udqC2xBu3JjrHPAyhNIAL79IFMfaa5XsSPo0ifFuSW5nIrYLXr70X2LpIbYRAMbWP_fTVji1QAX-SK9VRVhiQ_OlxQ)

- Флаги для ```git log ```
``` git log --graph ``` - отображает граф с ветвлениями и историей мержа
``` git log --online ``` - печатает каждый коммит в одну строку
``` git log --since/--until ``` - ограничение вывод по времени 
``` git log -p ``` - показывает патч каждого коммита
``` git log --stat ``` - показывает статистику об измененных файлах

- 	Чтобы откатить изменения без их сохранения ```git reset--hard HEAD~1``` 

- 	Чтобы внести изменения в последний коммит ``` git commit --amend```

- 	Чтобы добавить в коммит забытый файл 
```git commit -m "Do something"```
```git add <forgotten_file>```
```git commit --amend ```

- Чтобы измениь заголовок последнего коммита
``` git commit -m "Delete unused func" ```
``` git commit --amend -m "Delete unsed function in header file" ```

-   Добавить удаленную репу: ```git remote origin URL_репы```

-   Запушить(загрузить) изменения на удаленную репу:

```git push --set-upstream origin lab1``` (git push комманда для загруки --set-upstream origin <branch-name>) например branch-name в нашей лабе название ветки это lab1

-   Скачать изменения с удаленного репозитория ```git pull origin <ветка>``` в лабе вместо <ветка> будет lab1
### Ветвление

-   Создать ветку: ```git branch <название ветки>```

-   Переключение на ветку: ```git checkout  <название ветки>```

-   Чтобы создать ветку и сразу переключиться на нее: ```git checkout -b <название ветки>```

Допустим у вас есть ветка master вам нужно создать ветку с фиксом hotfix

``` git checkout -b hotfix ```

Производите изменения
``` git commit -a -m 'added hotfix' ```

Переключаетесь на master
``` git checkout master```

Проводите слияние веток
``` git merge hotfix ```

Удаление ветки после хотфикса
``` git branch -d hotfix ```

#### Управление ветками
``` git branch ``` - вывод списка всех веток
``` git branch --merged ``` - вывод влитых веток
``` git branch --no-merged ``` - вывод еще не влитых веток
``` git branch --move old-branch-name new-branch-name ``` - переименование веток(локально)
``` git push --set-upstream origin new-branch-name ``` - пуш переименования ветки
``` git push origin --delete old-branch-name ``` - удаление старой ветки со старым названием
``` git branch --all ``` - вывод всех веток

### Merge and Rebase

Когда вы используете `git merge`, Git создает новый коммит слияния, который объединяет изменения из двух веток.
Этот коммит имеет двух родителей - по одному от каждой ветки, которая была слита.
История каждой ветки сохраняется и остается наглядной и читаемой.
Каждая ветка сохраняет свою собственную историю разработки.
Как результат, история может стать более сложной и нелинейной, особенно при интенсивном использовании веток.

При использовании `git rebase`, Git берет коммиты из текущей ветки и применяет их поверх целевой ветки. Создаются новые коммиты, история становится линейной.
Этот подход позволяет создавать более чистую и линейную историю изменений, что может быть полезным для поддержания читаемости истории проекта.
При переписывании истории коммиты получают новые идентификаторы, что может вызвать проблемы при работе в тиме, если кто-то уже использовал старые идентификаторы.

### Переключаемся на целевую ветку, например, master
``` git checkout master ``` -  переключаемся на master
``` git rebase feature-branch ``` - применяем коммиты из master на feacture-branch
``` git rebase --continue ``` - продолжит ребейз не смотря на конфлиты
``` git checkout feature-branch ``` - переключаемся на ветку с фичей которую ребейзим
``` git rebase new-base-branch ``` -  завершаем ребейз на новой ветке

## gitignore 

```.gitignore``` - это файл в Git, который содержит список файлов, расширений или папок, которые вы хотите исключить из отслеживания системы контроля версий. Использование .gitignore помогает избежать добавления лишних файлов в репозиторий, таких как временные файлы, скомпилированные бинарные файлы, файлы настроек и т. д.

Зачем нужен ```.gitignore```
-   Исключение бинарных файлов: Компилированные файлы например a.out
-   Кэш файлов сборки/генераторов файлов сборки например при использовании cmake создаются папки: CMakeFIles  .cmake и файлы CMakeCache.txt cmake_install.cmake, у билд системы ninja создаются файлы .ninja_deps .ninja_log
-   Скомпилированные динамические библиотеки: .dll(на windows) .so (на linux)
-   Скомпилированные статические библиотеки: .a(linux) .lib(windows)

Пример ```.gitignore``` для C и C++:
```gitignore
#Пререквизиты:
*.d

#Скомпилированные объектные файлы:
*.slo
*.lo
*.o
*.obj

#Предварительно скомпилированные заголовки
*.gch
*.pch

#Скомпилированные динамические библиотеки
*.so
*.dylib
*.dll

#Файлы резервных копий редактора
*~
.*.swp

#Скомпилированные статические библиотеки
*.lai
*.la
*.a
*.lib
#Исполняемые файлы
*.exe
*.out
*.app

#файлы сборки(для лаб они не нужны но будут полезны если решите изучать плюсы и тулинг для них дальше)
.ninja_*
CMakeFiles/*
Testing/*
.cmake/*
CMakeCache.txt
build_ninja
cmake_install.cmake
```

Полезные ресурсы по git:
```
https://learngitbranching.js.org/
https://git-scm.com/book/en/v2
https://git-scm.com/videos
```

# Гайд по сборке C/C++ для начинающих

Исходный C++ файл который вы пишете в .c и .cpp это всего лишь код, его нельзя запустить напрямую. Чтобы из .c/.cpp получить .exe/.dll(на windows) .out, .so(на linux) его необходимо скомпилировать.
## Нужные пакеты на linux

Сохраните это как setup_script.sh
потом выполните ```chmod +x setup_script.sh | ./setup_script.sh```
```bash
#!/bin/bash
# Проверка типа дистрибутива
if [ -x "$(command -v apt-get)" ]; then
    sudo apt-get update
    sudo apt-get install -y build-essential neofetch git clang clang-tools gcc cmake make ninja-build lld lldb valgrind clang-format

elif [ -x "$(command -v dnf)" ]; then
    sudo dnf install -y @development-tools neofetch git clang clang-tools-extra gcc cmake make ninja-build lld lldb valgrind


else
    echo "Не удалось определить дистрибутив и установщик пакетов."
    exit 1
fi

```
gcc или clang на выбор

## Процесс компиляции C++ программы:

### Шаг 1: Препроцессинг

Препроцессинг - это первый этап компиляции, где препроцессор обрабатывает исходный код до самой компиляции. На этом этапе выполняются следующие действия:

Обработка директив препроцессора: ```#include``` вставляет содержимое указанного файла прямо в код. Макросы объявленные при помощи ```#define``` подставляются во всех местах в коде где они были использованы. Так же на этом этапе удаляются комментарии.

```cpp
// Пример
#include  <iostream>  //подключение заголовочного файла ввода вывода в C++
// будет произведена замена PI на 3.14159 во всех частях кода
#define PI 3.14159

int main()  {
	std::cout <<"hello"  << PI;
	return  0;
}
```

Чтобы получить файл который получится после препроцессинга можно воспользоваться флагом -E в компиляторе

 ```gcc/clang -E``` 
```clang++ -E main.cpp -o main.ii```

[Результат на godbolt](https://godbolt.org/z/h6417eh51)

### Шаг 2: Компиляция
Компиляция - это второй этап, на котором препроцессированный код преобразуется в объектные файлы.
Компиляция включает в себя преобразование препроцессированного кода на языке программирования в набор инструкций ассемблера. Этот этап создает объектные файлы (.o или .obj), содержащие машинный код, который представляет собой набор инструкций для конкретной архитектуры.(В примерах используется g++ но вы можете использовать clang++ просто введя вместо g++ - clang++)

Пример использования компилятора GCC для компиляции исходного файла:

```bash 
g++ -c main.cpp -o main.o
``` 

В данном примере:

-   `g++` - это вызов компилятора GCC для языка C++.
-   `-c` - флаг, указывающий компилятору создать только объектный файл.
-   `main.cpp` - имя исходного файла.
-   `-o main.o` - опция, указывающая имя выходного объектного файла.

### Шаг 3: Линковка

Линковка - это процесс объединения нескольких объектных файлов в один исполняемый файл. На этом этапе также происходит разрешение ссылок между различными частями программы.

Пример использования компилятора GCC для сборки объектных файлов в исполняемый файл:

`g++ main.o -o hello` 

В данном примере:

-   `g++` - вызов компилятора GCC для языка C++.
-   `main.o` - объектный файл, который нужно включить в сборку.
-   `-o hello` - опция, указывающая имя выходного исполняемого файла.

Теперь у вас есть исполняемый файл `hello`, который можно запустить:
```shell
./hello
```

Данные инструкции будут удобны если у нас 1 файл который нужно компилировать, но если файлов больше и/или код использует библиотеки то удобнее использовать системы сборки например make*.

*  make не является  системой сборки только для C/C++ это утилита автоматизирующая процесс преобразования файлов из одной формы в другую. Но чаще всего используется как билд система для C/C++.

## Использование [make](https://www.gnu.org/software/make/manual/make.html) для сборки проектов
### Написание Makefile

`Makefile` - это текстовый файл, содержащий инструкции для утилиты `make`. Этот файл определяет зависимости между файлами и указывает, какие команды нужно выполнить для сборки проекта.

Пример простого `Makefile`:

```makefile
CC = g++
CFLAGS = -Wall

all: hello

hello: main.o
	$(CC) $(CFLAGS) main.o -o hello
main.o: main.cpp
	$(CC) $(CFLAGS) -c main.cpp
clean:
	rm -rf *.o hello
```

В данном примере:

-   `CC` - это переменная, содержащая имя компилятора (в данном случае `g++`).
-   `CFLAGS` - флаги компиляции (в данном случае `-Wall` для вывода предупреждений).
-   `all` - цель по умолчанию, которая собирает исполняемый файл `hello`.
-   `hello` - цель для сборки исполняемого файла.
-   `main.o` - цель для сборки объектного файла `main.o`.
-   `clean` - цель для удаления временных файлов.

### Запуск утилиты make

1.  Создайте файл с именем `Makefile` в корневой директории проекта.
2.  Добавьте необходимые инструкции в `Makefile`.
3.  Откройте терминал и перейдите в директорию проекта.
4.  Выполните команду `make` для сборки проекта.

### Запуск исполняемого файла

После успешной сборки проекта выполните следующую команду в терминале для запуска исполняемого файла:
`./hello`


## Сборка проектов использующих [cmake](https://cmake.org/) 
Часто вы можете увидеть проекты в корне которых есть файл CMakeLists.txt это файл описания генерации файлов сборки при помощи cmake
Использование cmake для проектов содержащих 4+ файлов вместо make имхо уже необходимо для большего удобства
Для того чтобы собрать такие проекты нужно перейти в директорую с проектом `cd ProjectDir`
Там создать и перейти в папку build `mkdir build && cd build`
Выполнить ```cmake ..```
После будет выполнена генерация файлов систем сборки таких как `make` или `ninja`
Чтобы сгенерировать файлы сборки для определенной системы сборки например для `ninja` нужно выполнить `cmake ..-G=Ninja`
Чтобы сгенерировать файлы сборки для утилиты `make` нужно выполнить `cmake .. -G="Unix Makefiles"`
Чтобы начать сборку проекта нужно выполнить `ninja -j$(nproc)` или `make -j$(nproc)` для ninja[^1]
Чтобы запустить исполняемый файл нужно выполнить `./<название_исполняемого_файла>`
Название исполняемого файла можно узнать посмотрев в файл CMakeLists.txt на строчку ```project()```

[^1]: Лично я предпочитаю ninja потому что он быстрее собирает


## Простейший CMakeLists.txt для сборки проекта на C++
```cmake
cmake_minimum_required(VERSION 3.20)
project(<Название проекта>)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

add_executable(<Название проекта> main.cpp)
```

## Как использовать [clang-format](https://clang.llvm.org/docs/ClangFormat.html) - форматтер кода
```sh
clang-format -style=google -dump-config > .clang-format
clang-format -i *.cpp #если форматируете руками, не в редакторе кода
```

Обычно форматировать код в ручную не нужно этим занимается [vscode](https://marketplace.visualstudio.com/items?itemName=xaver.clang-format) и все популярные ide по сохранению файла

## CMake и статические библиотеки

Бывает так что вам нужно какую то часть вашего кода использовать как статическую библиотеку.
Чтобы это было удобно сделать можно создать примерно такую структуру файлов:
```
|---src
|    \
|		CMakeLists.txt
|		 main.cpp
|---mystaticlib
|	\
|	 CMakeLists.txt
|	  MyStaticLibrary.cpp
|	  MyStaticLibrary.hpp
|
|---CMakeLists.txt
```

`src` содержит `main.cpp` в код которого будет включаться статически линкующуюся библиотека из поддиректории mystaticlib

`CMakeLists.txt` в находящийся в корне будет выглядеть примерно так:

```cmake
cmake_minimum_required (VERSION 3.20)
project (Example)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON) # это нужно чтобы ланг сервер в vscode мог лучше понять написаный вами код

add_subdirectory (mystaticlib)
add_subdirectory (src)
```
`CMakeLists.txt` в находящийся в папке `mystatilib` будет выглядеть примерно так:
```cmake
cmake_minimum_required (VERSION 3.20)
 
project(mystatilib)
 
set(SOURCE_FILES "MyStaticLibrary.cpp")
set(HEADER_FILES "MyStaticLibrary.h")
 
# Мы объявляем проект как статическую библиотеку и добавляем в нее все файлы исходного кода.
add_library(MyStaticLibrary STATIC ${HEADER_FILES} ${SOURCE_FILES})
```
`CMakeLists.txt` в находящийся в папке `src` будет выглядеть примерно так:
```cmake
cmake_minimum_required (VERSION 3.20)
 
project(exampleStatic)
 
set(SOURCE_FILES "main.cpp")
 
add_executable (exampleStatic ${SOURCE_FILES})
 
# Подключаем библиотеку, указываем откуда брать заголовочные файлы
include_directories("../MyStaticLibrary")
# А также указываем зависимость от статической библиотеки
target_link_libraries(exampleStatic mystatilib)
```

Документация по [cmake](https://cmake.org/documentation/)

## Дебаггер и профилировщик
Бывает так что программа ведет себя не так как вы предполагали. И тогда нужно отладить конечную программу чтобы найти ошибки .
Для дебага(отладки) C и C++ существуют специальные программы -  дебаггеры.
На linux существуют 2 чаще используемых дебаггера это GDB/[LLDB](https://lldb.llvm.org/use/tutorial.html) и Valgrind

### Как пользоваться дебаггерами(lldb краткий экскурс)
Для начала нужно скопилировать проект с флагом -g чтобы компилятор сохранил информацию о компиляции которая будет полезна для дебаггера

``` clang++ -g main.cpp -o main ```

Далее нужно запустить программу используя lldb

``` lldb ./main ```

Так же можно добавить условие в CMakeLists.txt чтобы если сборка будет производится в дебаг режиме флаг подставлялся автоматически
```cmake
if (DEBUG)
    add_compile_options(-g3 -ggdb)
    add_compile_definitions(DEBUG)
endif()
```

Основные комманды LLDB:
* Запустить программу
```run```

* Остановка выполнения
```process interrupt```

* Получить информацию о стеке вызовов
```thread backtrace```

* Установить брейкпоинт(точку останова):
```breakpoint set --name functionName```

* Установить условный брейкопинт:
```breakpoint set --name functionName --condition 'expression'```

* Использование вочпоинтов
Watchpoints позволяют останавливаться при изменении значения переменной:
```watchpoint set variable varName ```

* Продолжение выполнения
```process continue```

* Вывод значений переменной
```expr varName```

* Вывод информации о переменных и типах
```image lookup -a address```

* Сохранение дебаг сессии
```save``` и ее загрузка ```target create```

Так же в редакторах кода и ide(VSCode и Clion например) есть gui для создания брейк поинтов, отслеживания значения переменной в данный момент и подстановки выражений

### Как пользоваться дебаггерами([gdb](https://sourceware.org/gdb/current/onlinedocs/) краткий экскурс)
1.  **Компиляция с флагом `-g`:**
    `g++ -g main.cpp -o main` 
   
    Или для использования GCC:

    `gcc -g main.c -o main` 
    
2.  **Запуск GDB:**
    `gdb ./main` 
    
3.  **Условия в CMakeLists.txt:**
    `if (DEBUG)
        add_compile_options(-g3 -ggdb)
        add_compile_definitions(DEBUG)
    endif()` 
    
4.  Основные команды GDB:
      * Запуск программы:
        ```run``` 
        
    -   Прерывание выполнения:
        `Ctrl+C` 
        
    -   Информация о стеке вызовов:
        `bt` 
        
    -   Установка брейкпоинта:
        `break functionName` 
        
    -   Установка условного брейкпоинта:
        `break functionName if expression` 
        
    -   Использование watchpoints:
        `watch varName` 
        
    -   Продолжение выполнения:
        `continue` 
        
    -   Вывод значения переменной:
        `print varName` 
        
       * Вывод информации о переменных и типах:
        ``` info locals```
        или
        ```ptype typeName ```
        
    -   *Сохранение и загрузка сессии:
        `save breakpoints filename`
        и
        `source filename`

### Как пользоваться дебаггерами([valgrind](https://valgrind.org/docs/manual/manual.html) краткий экскурс)
Так же может быть такое что ваша программа может иметь ошибки с памятью(течь по памяти например)
Для начала нужно скопилировать проект с флагом -g чтобы компилятор сохранил информацию о компиляции которая будет полезна для дебаггера

``` clang++ -g main.cpp -o main ```

Далее нужно запустить программу используя valrind

``` valgrind --leak-check=full -s ./main ```

Флаг --leak-check=full включает проверку утечек памяти.

* Valgrind выдаст общий отчет об утечках памяти после завершения выполнения программы.
* Для получения более подробной информации о местах утечек, смотрите выходные данные Valgrind.
* Valgrind также может обнаруживать ошибки чтения и записи в неинициализированные области памяти.

Как будет выглядеть утечка памяти в valgrind

Например у нас есть код в котором мы забыли освободить память:
```cpp
#include <cstdlib>
int main() {
    int *myArray = new int[5]; // выделение памяти для массива
    // забыли удалить память
    return 0;
}
```

```sh
==2581524== Memcheck, a memory error detector
==2581524== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==2581524== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
==2581524== Command: ./main --leak-check=full -s
==2581524== 
==2581524== 
==2581524== HEAP SUMMARY:
==2581524==     in use at exit: 20 bytes in 1 blocks
==2581524==   total heap usage: 2 allocs, 1 frees, 73,748 bytes allocated
==2581524== 
==2581524== LEAK SUMMARY:
==2581524==    definitely lost: 20 bytes in 1 blocks <-  ͟п͟о͟т͟е͟р͟я͟н͟о͟ ͟2͟0͟ ͟б͟а͟й͟т͟
==2581524==    indirectly lost: 0 bytes in 0 blocks
==2581524==      possibly lost: 0 bytes in 0 blocks
==2581524==    still reachable: 0 bytes in 0 blocks
==2581524==         suppressed: 0 bytes in 0 blocks
```
Как видно из вывода valgrind у нас есть 2 аллокации и всего 1 free, так же valgrind указал что мы потеряли 20 байт 

что означает вывод valgrind:
```definitely lost: количество байт, которые были выделены и потеряны, и на которые нет указателей.```
```indirectly lost: количество байт, которые были выделены, потеряны и не могут быть восстановлены.```
```possibly lost: количество байт, которые, возможно, утрачены, но есть указатели, ведущие к этой утраченной памяти.```
```still reachable: количество байт, которые еще доступны через указатели, но не были освобождены.```
```suppressed: количество байт, которые были подавлены и не учитываются в отчете.```

Как будет выглядеть процесс дебага кода в lldb:
```cpp
#include <iostream>
int main() {
    int x = 10;
    int y = 0;
    int result = x / y;  // ошибка: деление на ноль

    std::cout << "Result: " << result << std::endl;

    return 0;
}
```
* Компиляция с флагом -g для сохранения отладочной информации ``` clang++ -g main.cpp -o main ```
* Запуск программы в lldb ```lldb ./main```
* Установка брейк поинт на строке 7 ```breakpoint set --file main.cpp --line 7```
* Запуск программы ```run``` ![](https://i.imgur.com/IxZokWx.png)
  
* Произойдет остановка на точке останова. Теперь вы можете выполнять пошаговую инструкцию. ```thread step-inst```
* Продолжайте выполнение программы пошагово и наблюдайте за ее состоянием ``` continue ```


# Тестирование

### Введение в тестирование
Модульное тестирование в C++ с использованием [Google Test](https://google.github.io/googletest) и CMake:

  
Модульное тестирование в C++ является важной практикой разработки программного обеспечения, позволяющей проверить корректность работы отдельных функций или модулей кода. В контексте модульного тестирования, минимальной тестируемой единицей является функция. Писать тесты удобно в отдельных файлах, где для каждой тестируемой функции создается соответствующий файл с тестами.


Шаблон проекта с использованием CMake:

Создайте структуру каталогов для вашего проекта. Предположим, у вас есть следующая структура каталогов:

```sh
├── CMakeLists.txt
├── src
│ ├── my_code.cpp
│ └── CMakeLists.txt
├── test
│ ├── test_my_code.cpp
│ └── CMakeLists.txt

```

CMakeLists.txt в корневом каталоге:
```cmake
cmake_minimum_required(VERSION 3.20)
project(MyProject)

add_subdirectory(src)
add_subdirectory(test)
```

CMakeLists.txt в каталоге src:
```cmake
add_library(my_code my_code.cpp)
```

CMakeLists.txt в каталоге test:
```cmake
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

add_executable(test_my_code test_my_code.cpp)
target_link_libraries(test_my_code my_code ${GTEST_LIBRARIES} pthread)
```

Пример `my_code.cpp`:

```cpp
// src/my_code.cpp
int  add(int  a,  int  b)  {
return a + b;
}
```

Пример `test_my_code.cpp`:
```cpp
// test/test_my_code.cpp
#include  <gtest/gtest.h>
#include  "my_code.cpp"

TEST(AddTest, PositiveNumbers)  {
EXPECT_EQ(add(2,  3),  5);
}

TEST(AddTest, NegativeNumbers)  {
EXPECT_EQ(add(-2,  -3),  -5);
}

int  main(int  argc,  char  **argv)  {
::testing::InitGoogleTest(&argc, argv);
return  RUN_ALL_TESTS();
}

```

### Основные макросы [GTest](https://google.github.io/googletest/primer.html):
Google Test (GTest) предоставляет различные макросы для написания тестов в C++. Вот основные макросы, которые часто используются при написании тестов с использованием GTest:

```cpp
TEST(test_case_name, test_name)
```

### Определяет новый тест.
test_case_name: Имя тестового случая (группы тестов).
test_name: Имя теста внутри тестового случая.
```cpp

TEST(MathTest, Addition)  {
// Тестирование сложения
// ASSERT_ или EXPECT_ макросы используются для проверки условий
}
```
### ASSERT_ и EXPECT_ макросы:
Используются для проверки условий в тестах. Если условие не выполняется, ASSERT_ вызывает завершение теста, а EXPECT_ продолжает выполнение теста.

```cpp

ASSERT_EQ(expected, actual); // Проверка на равенство

ASSERT_NE(val1, val2); // Проверка на неравенство

ASSERT_TRUE(condition); // Проверка на true

ASSERT_FALSE(condition); // Проверка на false

ASSERT_EQ(expected, actual) и EXPECT_EQ(expected, actual)

```

### Проверка на равенство.

```cpp
ASSERT_NE(val1, val2) и EXPECT_NE(val1, val2)
```

  

### Проверка на неравенство.

```cpp
ASSERT_TRUE(condition) и EXPECT_TRUE(condition)
```

### Проверка на истинность.

```cpp

ASSERT_FALSE(condition) и EXPECT_FALSE(condition)

```

### Проверка на ложность.

```cpp

ASSERT_THROW(statement, exception_type) и EXPECT_THROW(statement, exception_type)

```

### Проверка, что выполнение statement генерирует исключение определенного типа.

```cpp
ASSERT_THROW(throwAnException(), MyException);

ASSERT_NO_THROW(statement) и EXPECT_NO_THROW(statement)
```

### Проверка, что выполнение statement не генерирует исключение.

```cpp

ASSERT_NO_THROW(doSomething());

ASSERT_STREQ(expected_str, actual_str) и EXPECT_STREQ(expected_str, actual_str)

```

### Проверка, что две строки равны.

```cpp
ASSERT_STREQ("hello", myString.c_str());

ASSERT_LT(val1, val2) и EXPECT_LT(val1, val2)
```

### Проверка, что val1 меньше val2.

```cpp
ASSERT_LT(2,  5);

ASSERT_GT(val1, val2) и EXPECT_GT(val1, val2)
```

### Проверка, что val1 больше val2.

```cpp
ASSERT_GT(5,  2);
```

Эти макросы помогают создавать тесты с использованием GTest.

  

## Использование [CTest](https://cmake.org/cmake/help/latest/manual/ctest.1.html) для автоматизации тестирования

  

CTest — это инструмент, входящий в комплект поставки CMake, который предоставляет средства для автоматизации и управления тестированием ваших проектов. Добавление поддержки CTest к вашему проекту позволяет удобно интегрировать тестирование в процесс сборки, а также легко использовать его в системах непрерывной интеграции.
* Автоматическое обнаружение тестов: CTest способен автоматически обнаруживать и запускать тесты в вашем проекте. Это упрощает процесс добавления новых тестов и поддержки существующих.
* Параметризация тестов: CTest позволяет параметризовать тесты, что облегчает создание вариантов тестов для различных сценариев и входных данных.
* Интеграция с CD/CI: Автоматическое выполнение тестов при каждом изменении кода в системе непрерывной интеграции обеспечивает постоянную проверку работоспособности вашего проекта.

.gitlab-ci.yml:
```yaml
stages:
-  test

test:

script:
-  mkdir build
-  cd build
-  cmake ..
-  make
-  ctest  # Запуск тестов с использованием CTest
```
Этот блок в файле .gitlab-ci.yml интегрирует CTest в процесс непрерывной интеграции. После построения проекта, команда ctest запускает тесты, а результаты могут быть легко анализированы в системе CI/CD.

## Где писать код(личные рекомендации)
Если вам приспичит перелезть на Linux то я бы рекомендовал `VSCode` или же `CLion`(если сможете найти халявную лицуху)
Для `VSCode` у меня есть профиль с готовым набором расширением для разработки на C++ и C его можете найти  [туть](https://github.com/cppshizoidS/dotfiles) в папочке [vscode](https://github.com/cppshizoidS/dotfiles/blob/main/vscode/BasicC%2B%2B.code-profile)

## Где учить C++
Документация от [IBM](https://www.ibm.com/docs/en/zos/3.1.0?topic=zos-xl-cc)
Список книг:
* Принципы и практика с использованием C++ - Бьерн Страуструп
* Язык программирования C++. Лекции и упражнения - Стивен Прата. 
* Язык программирования C++ краткий курс Бьерн Страуструп
* C++ Templates David Vandevoorde Nicolai M. Josuttis Douglas Gregor
* Ваш главный друг - справочник [cppreference](https://en.cppreference.com/w/)
* 
