\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}\usepackage{titling}
\usepackage{tikz}
\usetikzlibrary{graphs} 
\usetikzlibrary{arrows.meta}


\setlength{\droptitle}{-4cm}


\begin{document}
\title{%
  \large Вопросы к экзамену по дискретной математике }
  \date{}
  \author{}
\maketitle

\section*{Множества} 

\subsection*{1. Определения, способы задания множеств, декартово произведение множеств, операции над множествами, свойства операций над множествами}

\subsubsection*{Определения}

\textbf{Множество} - это совокупность объектов, которые рассматриваются как единое целое. Объекты, входящие в множество, называются элементами этого множества. Множество обычно обозначается заглавной буквой (например, \( A \), \( B \), \( C \)).

\subsubsection*{Способы задания множеств}

1. \textbf{Перечисление элементов}: множество задается перечислением всех его элементов в фигурных скобках. Например,
   \[
   A = \{1, 2, 3, 4\}
   \]
   Это множество состоит из элементов 1, 2, 3 и 4.

2. \textbf{Задание свойством}: множество задается описанием свойства, которому удовлетворяют все его элементы. Например,
   \[
   B = \{x \mid x \text{ — четное число}\}
   \]
   Это множество состоит из всех четных чисел.

3. \textbf{Построение по правилам}: множество задается с помощью правила или функции. Например,
   \[
   C = \{x^2 \mid x \in \mathbb{N}\}
   \]
   Это множество состоит из квадратов всех натуральных чисел.
   
\subsubsection*{Декартово произведение множеств}

\textbf{Декартово произведение} (или прямое произведение) двух множеств \( A \) и \( B \) - это множество всех упорядоченных пар, где первый элемент пары принадлежит множеству \( A \), а второй элемент пары принадлежит множеству \( B \). Обозначается \( A \times B \).

Формально:
\[
A \times B = \{ (a, b) \mid a \in A \text{ и } b \in B \}
\]

Например, если
\[
A = \{1, 2\} \text{ и } B = \{x, y\},
\]
то декартово произведение \( A \times B \) будет следующим множеством:
\[
A \times B = \{ (1, x), (1, y), (2, x), (2, y) \}.
\]

\subsection*{2. Операции над множествами}

1. \textbf{Объединение}: Объединение множеств \( A \) и \( B \) (обозначается \( A \cup B \)) - это множество, содержащее все элементы, которые принадлежат хотя бы одному из этих множеств.
   \[
   A \cup B = \{ x \mid x \in A \text{ или } x \in B \}
   \]

2. \textbf{Пересечение}: Пересечение множеств \( A \) и \( B \) (обозначается \( A \cap B \)) - это множество, содержащее все элементы, которые принадлежат обоим множествам.
   \[
   A \cap B = \{ x \mid x \in A \text{ и } x \in B \}
   \]

3. \textbf{Разность}: Разность множеств \( A \) и \( B \) (обозначается \( A \setminus B \)) - это множество, содержащее все элементы, которые принадлежат множеству \( A \), но не принадлежат множеству \( B \).	
   \[
   A \setminus B = \{ x \mid x \in A \text{ и } x \notin B \}
   \]

4. \textbf{Дополнение}: Дополнение множества \( A \) относительно универсального множества \( U \) (обозначается \( A^c \) или \( \overline{A} \)) - это множество, содержащее все элементы универсального множества \( U \), которые не принадлежат множеству \( A \).
   \[
   A^c = \{ x \mid x \in U \text{ и } x \notin A \}
   \]

\pagebreak
\subsection*{3. Свойства операций над множествами}

1. \textbf{Свойства объединения}: \hfill\break
   - Коммутативность: \( A \cup B = B \cup A \) \hfill\break
   - Ассоциативность: \( A \cup (B \cup C) = (A \cup B) \cup C \) \hfill\break
   - Идемпотентность: \( A \cup A = A \) \hfill\break
   - Поглощающий элемент: \( A \cup \emptyset = A \) \hfill\break

2. \textbf{Свойства пересечения}:\hfill\break
   - Коммутативность: \( A \cap B = B \cap A \) \hfill\break
   - Ассоциативность: \( A \cap (B \cap C) = (A \cap B) \cap C \) \hfill\break
   - Идемпотентность: \( A \cap A = A \) \hfill\break
   - Поглощающий элемент: \( A \cap U = A \) \hfill\break

3. \textbf{Свойства разности}:\hfill\break
   - Поглощение: \( A \setminus A = \emptyset \) \hfill\break
   - Разность с пустым множеством: \( A \setminus \emptyset = A \) \hfill\break
   - Разность с универсальным множеством: \( A \setminus U = \emptyset \) \hfill\break

4. \textbf{Свойства дополнения}:\hfill\break
   - Двойное дополнение: \( (A^c)^c = A \) \hfill\break
   - Закон де Моргана:\hfill\break
     - \( (A \cup B)^c = A^c \cap B^c \)\hfill\break
     - \( (A \cap B)^c = A^c \cup B^c \)\hfill\break

5. \textbf{Связь объединения и пересечения}:\hfill\break
   - Дистрибутивность:\hfill\break
     - \( A \cup (B \cap C) = (A \cup B) \cap (A \cup C) \)\hfill\break
     - \( A \cap (B \cup C) = (A \cap B) \cup (A \cap C) \)\hfill\break
\pagebreak

\subsection*{4. Отношения, свойства отношений}
\begin{itemize}
\item \textbf{Отношение} на множествах \( A \) и \( B \) - это подмножество декартова произведения \( A \times B \). Если \( (a, b) \in R \), где \( R \) - отношение, то говорят, что элемент \( a \) находится в отношении \( R \) с элементом \( b \).

\item\textbf{Свойства отношений}:
- \item\textbf{Рефлексивность}: отношение \( R \) на множестве \( A \) рефлексивно, если для любого \( a \in A \), \( (a, a) \in R \).
- \item\textbf{Симметричность}: отношение \( R \) на множестве \( A \) симметрично, если для любых \( a, b \in A \), если \( (a, b) \in R \), то \( (b, a) \in R \).
- \item\textbf{Антисимметричность}: отношение \( R \) на множестве \( A \) антисимметрично, если для любых \( a, b \in A \), если \( (a, b) \in R \) и \( (b, a) \in R \), то \( a = b \).
- \item\textbf{Транзитивность}: отношение \( R \) на множестве \( A \) транзитивно, если для любых \( a, b, c \in A \), если \( (a, b) \in R \) и \( (b, c) \in R \), то \( (a, c) \in R \).
\end{itemize}


\subsection*{5. Композиция отношений}

Пусть \( R \) - отношение на множествах \( A \) и \( B \), а \( S \) - отношение на множествах \( B \) и \( C \). Композицией отношений \( R \) и \( S \) (обозначается \( S \circ R \)) называется отношение на множествах \( A \) и \( C \), определяемое следующим образом: \( (a, c) \in S \circ R \), если существует такой элемент \( b \in B \), что \( (a, b) \in R \) и \( (b, c) \in S \).

\subsection*{6. Представление отношений в виде матрицы, проверка свойств отношений}

Отношение \( R \) на конечном множестве \( A = \{a_1, a_2, \ldots, a_n\} \) можно представить в виде матрицы \( n \times n \), где элемент \( a_{ij} \) равен 1, если \( (a_i, a_j) \in R \), и 0 в противном случае. Такая матрица называется матрицей смежности отношения.

Для проверки свойств отношений с помощью матрицы смежности используются следующие правила:
\begin{itemize}
    \item \textbf{Рефлексивность}: все элементы на главной диагонали матрицы должны быть равны 1.
    \item \textbf{Симметричность}: матрица должна быть симметричной относительно главной диагонали.
    \item \textbf{Антисимметричность}: если \( a_{ij} = 1 \) и \( a_{ji} = 1 \), то \( i = j \).
    \item \textbf{Транзитивность}: если \( a_{ij} = 1 \) и \( a_{jk} = 1 \), то \( a_{ik} = 1 \).
\end{itemize}


\subsection*{7. Отношение эквивалентности, отношение порядка}

\textbf{Отношение эквивалентности} на множестве \( A \) - это отношение, которое рефлексивно, симметрично и транзитивно. Если \( R \) - отношение эквивалентности на \( A \), то \( A \) можно разбить на непересекающиеся подмножества, называемые классами эквивалентности.

\textbf{Отношение порядка} на множестве \( A \) - это отношение, которое рефлексивно, антисимметрично и транзитивно. Если \( R \) - отношение порядка на \( A \), то говорят, что \( R \) задает на \( A \) частичный порядок. Если для любых \( a, b \in A \) выполняется \( a R b \) или \( b R a \), то \( R \) называется линейным (или тотальным) порядком.

\subsection*{8. Функции}

\textbf{Функция} (или отображение) из множества \( A \) в множество \( B \) - это правило, которое каждому элементу множества \( A \) ставит в соответствие ровно один элемент множества \( B \). Множество \( A \) называется областью определения функции, а множество \( B \) - областью значений функции. Если \( f \) - функция, \( A \) - её область определения, а \( B \) - область значений, то это обозначается как \( f: A \to B \).

\subsubsection*{Виды функций}
\begin{itemize}
    \item \textbf{Инъекция}: Функция \( f: A \to B \) является инъекцией, если для любых \( a_1, a_2 \in A \), если \( f(a_1) = f(a_2) \), то \( a_1 = a_2 \). Иначе говоря, различные элементы области определения переходят в различные элементы области значений.
    
    \item \textbf{Сюръекция}: Функция \( f: A \to B \) является сюръекцией, если для любого \( b \in B \) существует хотя бы один элемент \( a \in A \), такой что \( f(a) = b \). Иначе говоря, область значений функции совпадает со всем множеством \( B \).
    
    \item \textbf{Биекция}: Функция \( f: A \to B \) является биекцией, если она одновременно является и инъекцией, и сюръекцией. Иначе говоря, каждому элементу множества \( A \) соответствует ровно один элемент множества \( B \), и каждому элементу множества \( B \) соответствует ровно один элемент множества \( A \).
\end{itemize}

\subsubsection*{Свойства функций}

\begin{itemize}
    \item \textbf{Композиция функций}: Пусть \( f: A \to B \) и \( g: B \to C \) - две функции. Композицией функций \( f \) и \( g \) (обозначается \( g \circ f \)) называется функция \( g \circ f: A \to C \), определяемая как \( (g \circ f)(a) = g(f(a)) \) для всех \( a \in A \).
    
    \item \textbf{Обратная функция}: Пусть \( f: A \to B \) - биекция. Тогда существует обратная функция \( f^{-1}: B \to A \), которая каждому элементу \( b \in B \) ставит в соответствие такой элемент \( a \in A \), что \( f(a) = b \). Иначе говоря, \( f(f^{-1}(b)) = b \) и \( f^{-1}(f(a)) = a \) для всех \( a \in A \) и \( b \in B \).
    
    \item \textbf{Свойства композиции и обратных функций}:
    \begin{itemize}
        \item Композиция функций ассоциативна: \( h \circ (g \circ f) = (h \circ g) \circ f \) для любых функций \( f, g, h \).
        \item Если \( f \) и \( g \) - биекции, то \( (g \circ f)^{-1} = f^{-1} \circ g^{-1} \).
        \item Если \( f \) - биекция, то \( (f^{-1})^{-1} = f \).
    \end{itemize}
\end{itemize}

\pagebreak

\subsection*{9. Принцип математической индукции}

\textbf{Принцип математической индукции} - это метод доказательства, который используется для установления истинности утверждений, зависящих от натурального числа \( n \). Этот метод состоит из двух шагов:

\subsubsection*{Шаг 1. Базис индукции}

Необходимо доказать, что утверждение истинно для наименьшего значения \( n \). Обычно это \( n = 1 \) или \( n = 0 \). Этот шаг называется базисом индукции.

\subsubsection*{Шаг 2. Индукционный переход}

Необходимо доказать, что если утверждение истинно для некоторого \( n = k \), то оно истинно и для \( n = k + 1 \). Предположение о том, что утверждение истинно для \( n = k \), называется индукционным предположением.

Если оба шага выполнены, то утверждение считается доказанным для всех натуральных чисел \( n \).

\subsubsection*{Пример доказательства с использованием принципа математической индукции}

Рассмотрим пример доказательства с использованием принципа математической индукции. Докажем, что сумма первых \( n \) натуральных чисел равна \( \frac{n(n+1)}{2} \), то есть:
\[
1 + 2 + 3 + \ldots + n = \frac{n(n+1)}{2}.
\]

\textbf{Базис индукции:}

Для \( n = 1 \):
\[
1 = \frac{1 \cdot (1+1)}{2} = 1.
\]
Утверждение истинно для \( n = 1 \).

\textbf{Индукционный переход:}

Предположим, что утверждение истинно для \( n = k \), то есть:
\[
1 + 2 + 3 + \ldots + k = \frac{k(k+1)}{2}.
\]

Докажем, что утверждение истинно для \( n = k + 1 \):
\[
1 + 2 + 3 + \ldots + k + (k + 1).
\]
Используя индукционное предположение, имеем:
\[
1 + 2 + 3 + \ldots + k + (k + 1) = \frac{k(k+1)}{2} + (k + 1).
\]
Приведем правую часть к общему знаменателю:
\[
\frac{k(k+1)}{2} + \frac{2(k+1)}{2} = \frac{k(k+1) + 2(k+1)}{2} = \frac{(k+1)(k+2)}{2}.
\]
Таким образом, мы показали, что если утверждение истинно для \( n = k \), то оно истинно и для \( n = k + 1 \).

Следовательно, по принципу математической индукции, утверждение истинно для всех натуральных чисел \( n \).
\pagebreak

\section*{Комбинаторика}  
\textbf{ Комбинаторика - раздел математики, изучающий способы выбора и расположения элементов множества.}

\subsection*{1. Перестановки}
Перестановки - набор элементов состоящих из одних и тех же элементов и отличающиеся друг от друга только их порядком.
Например, если у нас есть множество \(\{1, 2, 3\}\), то перестановками этого множества будут все возможные способы расположить числа 1, 2 и 3 в ряд. Эти перестановки включают:
\begin{itemize}
    \item 1, 2, 3
    \item 1, 3, 2
    \item 2, 1, 3
    \item 2, 3, 1
    \item 3, 1, 2
    \item 3, 2, 1
\end{itemize}

Таким образом, перестановка - это способ переупорядочить элементы множества в разные последовательности.

\textbf{Количество перестановок \( n \) элементов:}
\[
P(n)=n!
\]
где \( n! \) (n факториал) = \( 1 \times 2 \times 3 \times \ldots \times n \).

\textbf{Пример:} \\
Сколько существует различных способов упорядочить 3 книги на полке?
\[
P(3) = 3! = 3 \times 2 \times 1 = 6
\]
\pagebreak

\subsection*{2. Размещения и сочетания без повторений}

\textbf{Размещения}

\textbf{Размещение} — это упорядоченное подмножество из \( k \) элементов, выбранных из множества из \( n \) элементов.

\textbf{Количество размещений без повторений:}
\[
A(n, k) = \frac{n!}{(n - k)!}
\]

\textbf{Пример:} \\
Сколько различных способов выбрать и упорядочить 2 книги из 5?
\[
A(5, 2) = \frac{5!}{(5 - 2)!} = \frac{5 \times 4 \times 3!}{3!} = 5 \times 4 = 20
\]

\textbf{Сочетания}

\textbf{Сочетание} — это неупорядоченное подмножество из \( k \) элементов, выбранных из множества из \( n \) элементов.

\textbf{Количество сочетаний без повторений:}
\[
C(n, k) = \binom{n}{k} = \frac{n!}{k! (n - k)!}
\]

\textbf{Пример:} \\
Сколько различных способов выбрать 2 книги из 5 без учета порядка?
\[
C(5, 2) = \binom{5}{2} = \frac{5!}{2! \times (5 - 2)!} = \frac{5 \times 4 \times 3!}{2! \times 3!} = \frac{5 \times 4}{2 \times 1} = 10
\]
\pagebreak

\subsection*{3. Размещения и сочетания с повторениями}

\textbf{Размещения с повторениями}

\textbf{Размещение с повторениями} — это упорядоченное подмножество из \( k \) элементов, выбранных из множества из \( n \) элементов, с возможностью повторения элементов.

\textbf{Количество размещений с повторениями:}
\[
A'(n, k) = n^k
\]

\textbf{Пример:} \\
Сколько различных способов выбрать и упорядочить 2 книги из 5, если книги могут повторяться?
\[
A'(5, 2) = 5^2 = 25
\]

\textbf{Сочетания с повторениями}

\textbf{Сочетание с повторениями} — это неупорядоченное подмножество из \( k \) элементов, выбранных из множества из \( n \) элементов, с возможностью повторения элементов.

\textbf{Количество сочетаний с повторениями:}
\[
C'(n, k) = \frac{(n+k-1)}{k} = \frac{(n+k-1)!}{k! (n-1)!}
\]

\textbf{Пример:} \\
Сколько различных способов выбрать 2 книги из 5 без учета порядка, если книги могут повторяться?
\[
C'(5, 2) = \binom{5+2-1}{2} = \binom{6}{2} = \frac{6!}{2! \times (6 - 2)!} = \frac{6 \times 5 \times 4!}{2! \times 4!} = \frac{6 \times 5}{2 \times 1} = 15
\]
\pagebreak

\subsection*{4. Обобщенные перестановки}


Обобщенные перестановки используются, когда некоторые элементы множества могут повторяться. 

\textbf{Количество обобщенных перестановок множества из \( n \) элементов с повторениями, где элементы \( a_1, a_2, \ldots, a_k \) повторяются \( n_1, n_2, \ldots, n_k \) раз соответственно:}
\[
P\left( \frac{n}{n_1, n_2, \ldots, n_k} \right) = \frac{n!}{n_1! n_2! \ldots n_k!}
\]

\textbf{Пример:} \\
Сколько различных слов можно составить из букв слова "LEVEL"?
\[
n = 5, \quad n_1 = 2 \text{ (L)}, \quad n_2 = 2 \text{ (E)}, \quad n_3 = 1 \text{ (V)}
\]
\[
P\left( \frac{5}{2, 2, 1} \right) = \frac{5!}{2! \times 2! \times 1!} = \frac{120}{2 \times 2 \times 1} = \frac{120}{4} = 30
\]
\pagebreak


\subsection*{5. Упорядоченные и не упорядоченные разбиения}
\textbf{Упорядоченные разбиения}

Упорядоченное разбиение множества включает в себя разбиение элементов множества на несколько групп с учетом порядка.

\textbf{Количество упорядоченных разбиений множества из \( n \) элементов на \( k \) групп:}
\[
P(n, k) = k^n
\]

\textbf{Пример:} \\
Сколько существует способов разделить 3 элемента на 2 группы с учетом порядка?
\[
P(3, 2) = 2^3 = 8
\]

\textbf{Неупорядоченные разбиения}

Неупорядоченное разбиение множества не учитывает порядок групп.

\textbf{Количество неупорядоченных разбиений множества из \( n \) элементов на \( k \) групп:}
\[
B(n, k) = \frac{1}{k!} \sum_{j=0}^{k} (-1)^j \binom{k}{j} (k-j)^n
\]
где \( B(n, k) \) — число Стирлинга второго рода.

\textbf{Пример:} \\
Сколько существует способов разделить 3 элемента на 2 неупорядоченные группы?
\[
B(3, 2) = \frac{1}{2!} \sum_{j=0}^{2} (-1)^j \binom{2}{j} (2-j)^3 = \frac{1}{2} \left( \binom{2}{0} 2^3 - \binom{2}{1} 1^3 + \binom{2}{2} 0^3 \right)
\]
\[
= \frac{1}{2} (8 - 2 + 0) = \frac{6}{2} = 3
\]
\pagebreak

\subsection*{6. Биноминальная теорема}

Биноминальная теорема описывает разложение степени суммы двух чисел.

\textbf{Формулировка биноминальной теоремы:}
\[
(a+b)^n = \sum_{k=0}^{n} \binom{n}{k} a^{n-k} b^k
\]
где \(\binom{n}{k}\) - биноминальные коэффценты.

\textbf{Пример:} \\
Рассмотрим разложение \((a + b)^3\):
\[
(a + b)^3 = \binom{3}{0} a^3 b^0 + \binom{3}{1} a^2 b^1 + \binom{3}{2} a^1 b^2 + \binom{3}{3} a^0 b^3
\]
\[
= 1 \cdot a^3 + 3 \cdot a^2 b + 3 \cdot a b^2 + 1 \cdot b^3
\]
\[
= a^3 + 3a^2b + 3ab^2 + b^3
\]
\pagebreak

\subsection*{7. Полиномиальная теорема}

Полиномиальная теорема обобщает биномиальную теорему для случая, когда суммируются больше двух слагаемых. 

\textbf{Формулировка полиномиальной теоремы:}
\[
(x_1 + x_2 + \cdots + x_m)^n = \sum_{k_1 + k_2 + \cdots + k_m = n} \frac{n!}{k_1! k_2! \cdots k_m!} x_1^{k_1} x_2^{k_2} \cdots x_m^{k_m}
\]
где сумма берется по всем наборам неотрицательных целых чисел \( k_1, k_2, \ldots, k_m \), таких что \( k_1 + k_2 + \cdots + k_m = n \).

\textbf{Пример:} \\
Рассмотрим разложение \((x + y + z)^3\):
\[
(x + y + z)^3 = \sum_{k_1 + k_2 + k_3 = 3} \frac{3!}{k_1! k_2! k_3!} x^{k_1} y^{k_2} z^{k_3}
\]
\[
= \frac{3!}{3! 0! 0!} x^3 y^0 z^0 + \frac{3!}{2! 1! 0!} x^2 y^1 z^0 + \frac{3!}{1! 2! 0!} x^1 y^2 z^0 + \frac{3!}{0! 3! 0!} x^0 y^3 z^0 
\]
\[
+ \frac{3!}{2! 0! 1!} x^2 y^0 z^1 + \frac{3!}{1! 1! 1!} x^1 y^1 z^1 + \frac{3!}{0! 2! 1!} x^0 y^2 z^1 
\]
\[
+ \frac{3!}{1! 0! 2!} x^1 y^0 z^2 + \frac{3!}{0! 1! 2!} x^0 y^1 z^2 + \frac{3!}{0! 0! 3!} x^0 y^0 z^3
\]
\[
= x^3 + 3x^2 y + 3x y^2 + y^3 + 3x^2 z + 6xy z + 3y^2 z + 3xz^2 + 3y z^2 + z^3
\]
\pagebreak

\subsection*{8. Формула включения и исключения}

Формула включения и исключения используется для нахождения количества элементов в объединении нескольких множеств с учетом их пересечений.

\textbf{Формула включения и исключения для двух множеств:}
\[
|A \cup B| = |A| + |B| - |A \cap B|
\]

\textbf{Для трех множеств:}
\[
|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C|
\]

\textbf{Обобщенная формула для \( n \) множеств:}
\[
\left| \bigcup_{i=1}^{n} A_i \right| = \sum_{k=1}^{n} (-1)^{k+1} \sum_{1 \leq i_1 < i_2 < \cdots < i_k \leq n} \left| A_{i_1} \cap A_{i_2} \cap \cdots \cap A_{i_k} \right|
\]

\textbf{Пример:} \\
Рассмотрим три множества \( A, B \) и \( C \), где:
\[
|A| = 10, \quad |B| = 15, \quad |C| = 20, \quad |A \cap B| = 5, \quad |A \cap C| = 4, \quad |B \cap C| = 6, \quad |A \cap B \cap C| = 2
\]

Тогда количество элементов в объединении этих множеств:
\[
|A \cup B \cup C| = 10 + 15 + 20 - 5 - 4 - 6 + 2 = 32
\]
\pagebreak


\section*{Графы}  
\subsection*{1. Виды графов}


Виды графов можно разделить на неориентированные и ориентированные, взвешенные и невзвешенные.

\subsubsection*{Неориентированный граф}
Неориентированный граф представляет собой совокупность вершин, соединенных ребрами без определенного направления. Вершины обозначаются кругами, а ребра между ними - линиями без стрелок.

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  \draw (A) -- (B);
  \draw (B) -- (C);
  \draw (C) -- (A);
\end{tikzpicture}


\subsubsection*{Ориентированный граф}
Ориентированный граф также состоит из вершин и ребер, но каждое ребро имеет направление, обозначенное стрелкой. Это означает, что связь между вершинами однонаправленная.



\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  \draw[->] (A) -- (B);
  \draw[->] (B) -- (C);
  \draw[->] (C) -- (A);
\end{tikzpicture}
\pagebreak

\subsection*{2. Маршруты, цепи, циклы} 
\subsubsection*{Маршрут}
Маршрут: Последовательность вершин, где каждая вершина соединена ребрами последовательно.

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  \draw (A) -- (B) -- (C);
\end{tikzpicture}

\subsubsection*{Цепь}
Цепь: Маршрут, где все рёбра различны.

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  \draw (A) -- (B);
  \draw (B) -- (C);
\end{tikzpicture}

\subsubsection*{Цикл}
Цикл: Маршрут, где начальная и конечная вершины совпадают.

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  \draw (A) -- (B);
  \draw (B) -- (C);
  \draw (C) -- (A);
\end{tikzpicture}

\subsection*{3. Связность}

Связный граф: это граф, в котором между любой парой вершин существует путь. Граф из любой вершины которого можно добраться до любой другой вершины по ребрам.

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};
  \node[circle, draw] (D) at (3,-1.5) {D};

  \draw (A) -- (B);
  \draw (B) -- (C);
  \draw (C) -- (A);
  \draw (B) -- (D);
\end{tikzpicture}
\pagebreak

\subsection*{4. Операции над графами}
\subsubsection*{Добавление вершины и ребра:}
Добавление новой вершины или ребра в граф. Это позволяет расширять структуру графа, добавляя новые элементы.

Пример (добавление вершины и ребра):

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  % Добавление новой вершины D
  \node[circle, draw] (D) at (3,-1.5) {D};

  % Добавление нового ребра между вершинами A и D
  \draw (A) -- (D);
\end{tikzpicture}

\subsubsection*{Удаление вершины и ребра: }
Удаление существующей вершины или ребра из графа. Это может привести к изменению структуры графа путем удаления элементов.

Пример (удаление вершины и ребра):

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};
  \node[circle, draw] (C) at (1,-1.5) {C};

  % Удаление ребра между вершинами A и B
  \draw (A) -- (C);
\end{tikzpicture}

\subsubsection*{Изменение веса ребра: }
Если граф имеет взвешенные ребра (с ассоциированными числовыми значениями), можно изменять вес ребра. Это важно для алгоритмов поиска кратчайшего пути и минимального остовного дерева.

Пример (изменение веса ребра):

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};

  % Ребро с весом 5 между вершинами A и B
  \draw (A) -- node[above] {5} (B);

  % Изменение веса ребра на 8
  \draw (A) -- node[below] {8} (B);
\end{tikzpicture}

\subsubsection*{Транспонирование(для ориентированного графа): }
Транспонирование ориентированного графа - это процесс замены всех направленных ребер графа на противоположные. То есть если ребро было направлено от вершины A к B, после транспонирования оно будет направлено от B к A.

Пример (транспонирование ориентированного графа):

\begin{tikzpicture}
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,0) {B};

  % ориентированное ребро от A к B
  \draw[->] (A) -- (B);

  % транспонирование ребра: от B к A
  \draw[->] (B) -- (A);
\end{tikzpicture}

\pagebreak

\subsection*{5.Способы представления графа}
\subsubsection*{Матрица смежности}
Матрица смежности представляет граф в виде квадратной матрицы, где строки и столбцы соответствуют вершинам графа, а элементы матрицы указывают на наличие (или отсутствие) ребра между соответствующими вершинами. Для невзвешенных графов элементы матрицы обычно булевы (0 или 1), а для взвешенных - числовые (вес ребра).

Пример:
Для графа с вершинами A, B, C и ребрами (A, B) и (B, C):
\[
\begin{array}{c|ccc}
  & A & B & C \\
\hline
A & 0 & 1 & 0 \\
B & 1 & 0 & 1 \\
C & 0 & 1 & 0 \\
\end{array}
\]

\subsubsection*{Список смежности}
Список смежности представляет граф в виде списка, где каждая вершина имеет список смежных с ней вершин. В невзвешенных графах это может быть просто список соседей, а в взвешенных - пары (сосед, вес ребра).

Пример:
Для графа с вершинами A, B, C и ребрами (A, B) и (B, C):
\begin{verbatim}
A: B
B: A, C
C: B
\end{verbatim}

\subsubsection*{Список рёбер}
Список рёбер просто перечисляет все рёбра графа. В невзвешенных графах это просто пары вершин, а в взвешенных - пары (вершина1, вершина2, вес).

Пример:
Для графа с вершинами A, B, C и ребрами (A, B) и (B, C):
\begin{verbatim}
(A, B)
(B, C)
\end{verbatim}
\pagebreak

\subsection*{6.Нахождение минимального остового дерева(МОД)}
Нахождение минимального остовного дерева (МОД) в графе — это задача нахождения подмножества рёбер такого, что все вершины соединены и нет циклов, при этом сумма весов рёбер минимальна.

\subsubsection*{Алгоритм Прима для нахождения МОД}
Алгоритм Прима используется для нахождения МОД во взвешенном связном графе. Он начинает с одной произвольной вершины и постепенно добавляет к МОД рёбра минимального веса, соединяющие текущее дерево с новой вершиной.

Шаги алгоритма:
Инициализация: Выбрать произвольную начальную вершину.
Помечать вершины: Пометить начальную вершину как посещённую.
Выбор рёбер: Найти рёбро минимального веса, которое соединяет посещённую вершину с непосещённой.
Добавление в МОД: Добавить это ребро к МОД и пометить соединённую вершину как посещённую.
Повторение: Повторять шаги 3-4 до тех пор, пока не будут посещены все вершины.

Пример:
\begin{tikzpicture}
  % Вершины
  \node[circle, draw] (A) at (0,0) {A};
  \node[circle, draw] (B) at (2,1) {B};
  \node[circle, draw] (C) at (4,0) {C};
  \node[circle, draw] (D) at (2,-1) {D};
  
  % Рёбра с весами
  \draw[-latex, thick] (A) -- node[midway, above left] {2} (B);
  \draw[-latex, thick] (B) -- node[midway, above right] {3} (C);
  \draw[-latex, thick] (C) -- node[midway, below right] {1} (D);
  \draw[-latex, thick] (D) -- node[midway, below left] {4} (A);
  \draw[-latex, thick] (A) -- node[midway, above right] {5} (C);
\end{tikzpicture}
\pagebreak

\subsection*{7. Обходы графа}
Обходы графа — это процессы обхода всех вершин и рёбер графа в определённом порядке. Они играют ключевую роль в алгоритмах обработки и анализа графов. Существует несколько основных методов обхода графа: обход в глубину (Depth-First Search, DFS) и обход в ширину (Breadth-First Search, BFS).

\subsubsection*{Обход в глубину (DFS)}
Обход в глубину основан на идее посещения вершин настолько глубоко, насколько это возможно, перед тем как возвращаться и посещать другие вершины. Он часто реализуется с использованием стека.

Принцип работы:
\begin{itemize}
\item Начало с любой вершины: Начинаем с выбора начальной вершины и помечаем её как посещённую.

\item  Рекурсивный процесс: Для текущей вершины выбираем одну из её непосещённых смежных вершин и рекурсивно повторяем процесс.

\item  Возврат и поиск новых путей: Если у текущей вершины нет непосещённых смежных вершин, возвращаемся к предыдущей вершине в стеке и продолжаем поиск.

\item Завершение: Процесс завершается, когда все вершины графа будут посещены.

\end{itemize}

DFS часто используется для поиска в глубину, топологической сортировки, нахождения компонент связности и циклов в графе.

Пример:

\begin{tikzpicture}
  \foreach \i in {1,...,4} {
    \node[circle, draw] (\i) at (360/4*\i:2cm) {\i};
  }
  
  \foreach \j/\k in {1/2, 2/3, 3/4, 4/1, 1/3} {
    \draw (\j) -- (\k);
  }

  \node[fill=green!20, circle, draw] (start) at (0:0cm) {start};
  
  \draw[thick, red, ->] (start) -- (1);
  \draw[thick, red, ->] (1) -- (2);
  \draw[thick, red, ->] (2) -- (3);
  \draw[thick, red, ->] (3) -- (4);
\end{tikzpicture}
\pagebreak

\subsubsection*{Обход в ширину  (BFS))}
Обход в ширину это алгоритм обхода графа, который исследует вершины на одной уровне расстояния от начальной вершины, прежде чем переходить к вершинам следующего уровня. Он использует очередь для хранения вершин, которые нужно посетить, и отмечает вершины как посещённые, чтобы избежать повторного посещения.

Принцип работы:
\begin{itemize}
\item Инициализация: Начинаем с указания начальной вершины и помещаем её в очередь.

\item Извлекаем вершину из очереди.

\item Посещаем все соседние вершины этой вершины, которые ещё не были посещены.

\item Добавляем каждую соседнюю вершину в очередь и отмечаем её как посещённую.

\item Повторяем, пока очередь не опустеет.

\end{itemize}
BFS особенно полезен для поиска кратчайшего пути в невзвешенных графах и проверки связности графа.

Пример:

\begin{tikzpicture}[->,>=stealth, every node/.style={circle, draw, minimum size=7mm}]
    % nodes
    \node (1) at (0,0) {1};
    \node (2) at (2,0) {2};
    \node (3) at (4,0) {3};
    \node (4) at (1,-1.5) {4};
    \node (5) at (3,-1.5) {5};
    \node (6) at (2,-3) {6};
    
    % edges
    \draw (1) -- (2);
    \draw (2) -- (3);
    \draw (1) -- (4);
    \draw (2) -- (5);
    \draw (4) -- (5);
    \draw (4) -- (6);
    \draw (5) -- (6);
    
    % BFS path
    \draw[blue, thick] (1) -- (2);
    \draw[blue, thick] (2) -- (3);
    \draw[blue, thick] (1) -- (4);
    \draw[blue, thick] (4) -- (5);
    \draw[blue, thick] (5) -- (6);
\end{tikzpicture}
\pagebreak
 
\subsection*{8. Нахождение кратчайших путей}

\subsubsection*{Алгоритм Дейкстры}
Алгоритм Дейкстры используется для нахождения кратчайших путей от одной вершины (начальной) до всех остальных вершин во взвешенном графе с неотрицательными весами ребер.

Шаги алгоритма Дейкстры:
\begin{enumerate}
\item  Инициализация: Устанавливаем начальную вершину и расстояние до нее равным нулю, а все остальные вершины как бесконечность.

\item  Выбор вершины: Из текущих вершин выбираем ту, расстояние до которой наименьшее.

\item  Обновление расстояний: Для каждой смежной вершины пересчитываем расстояние: если новый путь короче текущего, обновляем расстояние.

\item  Повторение: Повторяем шаги 2 и 3, пока не обработаем все вершины.
\end{enumerate}

Восстановление пути: После завершения алгоритма можно восстановить кратчайший путь до любой вершины, используя информацию о предшествующих вершинах.


Пример:
Пусть дан следующий граф для примера алгоритма Дейкстры:

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[scale=1.2, auto, node distance=2cm, every node/.style={circle, draw}]
        \node (A) at (0,0) {A};
        \node (B) at (2,1) {B};
        \node (C) at (2,-1) {C};
        \node (D) at (4,1) {D};
        \node (E) at (4,-1) {E};
        
        \foreach \source/\dest/\weight in {A/B/4, A/C/2, B/C/5, B/D/2, C/E/4, D/E/1}
            \path[->] (\source) edge node {$\weight$} (\dest);
        
        % Highlight initial node A
        \draw[thick, red] (A) circle (0.3);
        
        % Distance labels
        \node[above right] at (A) {0};
        \node[above right] at (B) {$\infty$};
        \node[below right] at (C) {$\infty$};
        \node[above right] at (D) {$\infty$};
        \node[below right] at (E) {$\infty$};
    \end{tikzpicture}
    \caption{Граф для примера алгоритма Дейкстры}
\end{figure}
\pagebreak

Применим алгоритм Дейкстры для нахождения кратчайших путей из вершины A:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Вершина & Расстояние \\
\hline
A & 0 \\
B & $\infty$ \\
C & $\infty$ \\
D & $\infty$ \\
E & $\infty$ \\
\hline
\end{tabular}
\end{center}

Шаги алгоритма:

\begin{enumerate}
    \item Выбрана вершина A, расстояние до неё 0.
    \item Обновляем расстояния: B (расстояние до A + вес(A-B) = 4), C (расстояние до A + вес(A-C) = 2).
    \item Выбрана вершина C, обновляем расстояние до E (расстояние до C + вес(C-E) = 6).
    \item Выбрана вершина B, обновляем расстояние до D (расстояние до B + вес(B-D) = 6).
    \item Выбрана вершина D, обновляем расстояние до E (расстояние до D + вес(D-E) = 7).
    \item Алгоритм завершён, расстояния до всех вершин найдены.
\end{enumerate}

Таким образом, кратчайшие пути из вершины A: A -> C -> E.
\pagebreak

\subsubsection*{Алгоритм Беллмана-Форда}
Алгоритм Беллмана-Форда применяется для нахождения кратчайших путей в графе с ребрами произвольных весов, в том числе с отрицательными весами, но без циклов отрицательного веса.

Шаги и действия алгоритма:
\begin{enumerate}
    \item Инициализация: установить расстояние до начальной вершины как 0, а до всех остальных — как бесконечность.
    
    \item Итерации: повторить $|V|-1$ раз, где $|V|$ — количество вершин в графе.
    
    \item Обновление расстояний: для каждого ребра $(u, v)$ с весом $w(u, v)$, обновить расстояние до вершины $v$ как минимум из текущего расстояния и расстояния до $u$ плюс веса ребра $(u, v)$.
    
    \item Проверка наличия циклов отрицательного веса: если после $|V|-1$ итераций есть вершина, для которой расстояние можно улучшить, то в графе есть цикл отрицательного веса.
\end{enumerate}


Пример:

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}[scale=1.2, auto, node distance=2cm, every node/.style={circle, draw}]
        \node (A) at (0,0) {A};
        \node (B) at (2,1) {B};
        \node (C) at (2,-1) {C};
        \node (D) at (4,1) {D};
        \node (E) at (4,-1) {E};
        
        \foreach \source/\dest/\weight in {A/B/4, A/C/2, B/C/5, B/D/10, C/E/3, D/E/4}
            \path[->] (\source) edge node {$\weight$} (\dest);
        
        % highlight initial node A
        \draw[thick, red] (A) circle (0.3);
        
        % distance labels
        \node[above right] at (A) {0};
        \node[above right] at (B) {$\infty$};
        \node[below right] at (C) {$\infty$};
        \node[above right] at (D) {$\infty$};
        \node[below right] at (E) {$\infty$};
    \end{tikzpicture}
    \caption{Граф для примера алгоритма Беллмана-Форда}
\end{figure}

Применим алгоритм Беллмана-Форда для нахождения кратчайших путей из вершины A:

\begin{center}
\begin{tabular}{|c|c|}
\hline
Вершина & Расстояние \\
\hline
A & 0 \\
B & 4 \\
C & 2 \\
D & $\infty$ \\
E & $\infty$ \\
\hline
\end{tabular}
\end{center}

\pagebreak
Шаги алгоритма:

\begin{enumerate}
    \item Выбрана вершина A, расстояние до неё 0.
    \item Обновляем расстояния: B (расстояние до A + вес(A-B) = 4), C (расстояние до A + вес(A-C) = 2).
    \item Выбрана вершина B, обновляем расстояние до C (расстояние до B + вес(B-C) = 1).
    \item Выбрана вершина D, обновляем расстояние до E (расстояние до D + вес(D-E) = 3).
    \item Алгоритм завершён, расстояния до всех вершин найдены.
\end{enumerate}

Таким образом, кратчайшие пути из вершины A: A -> C -> E.
\pagebreak

\subsection*{9.  Эйлеровы и гамильтоновы графы }
\subsubsection*{Эйлеров путь}
Эйлеров путь в графе — это путь, который проходит через каждое ребро ровно один раз. Эйлеров цикл — это цикл, который проходит через каждое ребро ровно один раз и возвращается в исходную вершину.

\subsubsection*{Эйлеров цикл:}

Эйлеров цикл в графе — это цикл, который проходит через каждое ребро ровно один раз и возвращается в исходную вершину.
Для того чтобы граф содержал эйлеров цикл, он должен быть связным и каждая вершина должна иметь четную степень (количество инцидентных ребер).

\begin{center}
\begin{tikzpicture}
  [every node/.style={draw,circle,inner sep=0pt,minimum size=5mm},
   every edge/.style={draw,thick}]
   
  % вершины графа
  \foreach \i in {1,...,6}
    \node (\i) at (\i*360/6:2) {\i};
  
  % рёбра для эйлерова цикла
  \path[draw,thick,red]
    (1) edge[bend left] (2)
    (2) edge[bend left] (3)
    (3) edge[bend left] (4)
    (4) edge[bend left] (5)
    (5) edge[bend left] (6)
    (6) edge[bend left] (1);
    
\end{tikzpicture}
\end{center}


Эйлеров цикл: \(1 \to 2 \to 3 \to 4 \to 5 \to 6 \to 1 \)

\subsubsection*{Эйлеров граф}
Эйлеров граф — это связный граф, который содержит эйлеров цикл.

\begin{center}
\begin{tikzpicture}
  [every node/.style={draw,circle,inner sep=0pt,minimum size=5mm},
   every edge/.style={draw,thick}]
   
  % вершины графа
  \foreach \i in {1,...,6}
    \node (\i) at (\i*360/6:2) {\i};
  
  % рёбра для эйлерова графа
  \path[draw,thick,blue]
    (1) edge (2)
    (2) edge (3)
    (3) edge (4)
    (4) edge (5)
    (5) edge (6)
    (6) edge (1);
    
\end{tikzpicture}
\end{center}

Этот граф является эйлеровым, так как содержит эйлеров цикл: \(1 \to 2 \to 3 \to 4 \to 5 \to 6 \to 1\).


\subsubsection*{Гамильтонов цикл:}

Гамильтонов цикл в графе — это цикл, который проходит через каждую вершину ровно один раз и возвращается в исходную вершину.

\begin{center}
\begin{tikzpicture}
  [every node/.style={draw,circle,inner sep=0pt,minimum size=5mm},
   every edge/.style={draw,thick}]
   
  % вершины графа
  \foreach \i in {1,...,6}
    \node (\i) at (\i*360/6:2) {\i};
  
  % рёбра для гамильтонова цикла
  \path[draw,thick,blue]
    (1) edge (2)
    (2) edge (3)
    (3) edge (4)
    (4) edge (5)
    (5) edge (6)
    (6) edge (1);
    
\end{tikzpicture}
\end{center}

Пример гамильтонова цикла: \(1 \to 2 \to 3 \to 4 \to 5 \to 6 \to 1 \)

\subsubsection*{Гамильтонов граф}

Гамильтонов граф — это связный граф, который содержит гамильтонов цикл или гамильтонов путь.

\begin{center}
\begin{tikzpicture}
  [every node/.style={draw,circle,inner sep=0pt,minimum size=5mm},
   every edge/.style={draw,thick}]
   
  % вершины графа
  \foreach \i in {1,...,6}
    \node (\i) at (\i*360/6:2) {\i};
  
  % рёбра для гамильтонова графа
  \path[draw,thick,green]
    (1) edge (2)
    (2) edge (3)
    (3) edge (4)
    (4) edge (5)
    (5) edge (6)
    (6) edge (1)
    (1) edge (4)
    (2) edge (5)
    (3) edge (6);
    
\end{tikzpicture}
\end{center}

Пример гамильтонова графа: каждая вершина соединена таким образом, чтобы существовал гамильтонов цикл или путь.
\pagebreak

\subsection*{10.  Планарные графы }

Планарные графы — это такие графы, которые можно изобразить на плоскости таким образом, чтобы рёбра графа не пересекались, за исключением возможного пересечения в вершинах. Таким образом, они могут быть представлены на двумерной плоскости без пересечений рёбер.

Граф P4 (путь на 4 вершинах):
\begin{center}
\begin{tikzpicture}
\graph[circular placement, radius=2cm, empty nodes, nodes={circle, draw}] {
1 -- 2 -- 3 -- 4;
};
\end{tikzpicture}
\end{center}

Граф C4 (цикл на 4 вершинах):
\begin{center}
\begin{tikzpicture}
\graph[circular placement, radius=2cm, empty nodes, nodes={circle, draw}] {
1 -- 2 -- 3 -- 4 -- 1;
};
\end{tikzpicture}
\end{center}

Граф K4 (полный граф на 4 вершинах):
\begin{center}
\begin{tikzpicture}
\graph[circular placement, radius=2cm, empty nodes, nodes={circle, draw}] {
1 --[edge label=$e_1$] 2 --[edge label=$e_2$] 3 --[edge label=$e_3$] 4 --[edge label=$e_4$] 1;
1 --[edge label=$e_5$] 3;
2 --[edge label=$e_6$] 4;
};
\end{tikzpicture}
\end{center}
\pagebreak


\subsection*{11. Нахождение Компонент Связности в Графе}
Компонента связности в графе – это максимальное подмножество вершин, такое что между любыми двумя вершинами этого подмножества существует путь. В данной секции мы рассмотрим пример графа и разбиение его на компоненты связности.

\subsubsection*{Пример графа и его Компоненты Связности (КСС)}

% Пример графа
\begin{center}
\begin{tikzpicture}
  [every node/.style={circle, draw}]
  
  \graph[circular placement, radius=2cm, empty nodes] {
    1 -- 2 -- 3 -- 4 -- 1;
    5 -- 6;
    7 -- 8;
    9 -- 10 -- 11 -- 9;
    12 -- 13 -- 14 -- 12;
    1 -- 5 -- 9;
  };
\end{tikzpicture}
\end{center}

В данном графе присутствуют следующие связи:
\begin{enumerate}
\item Вершины 1, 2, 3 и 4 образуют цикл.
\item Вершины 5 и 6 соединены между собой.
\item Вершины 7 и 8 соединены между собой.
\item Вершины 9, 10 и 11 образуют цикл.
\item Вершины 12, 13 и 14 образуют цикл.
\item Вершина 1 соединена с вершиной 5, которая в свою очередь соединена с вершиной 9.
\end{enumerate}
Теперь мы выделим компоненты связности в этом графе.

\pagebreak

\subsection*{12. Раскраска графа}
\begin{center}
\begin{tikzpicture}
  [every node/.style={circle, draw, minimum size=6mm}]
  % КСС 1
  \node (1) at (0, 4) {1};
  \node (2) at (2, 4) {2};
  \node (3) at (2, 2) {3};
  \node (4) at (0, 2) {4};
  \draw (1) -- (2) -- (3) -- (4) -- (1);
  \node at (1, 1.5) {КСС 1};
  
  % КСС 2
  \node (5) at (5, 4) {5};
  \node (6) at (7, 4) {6};
  \draw (5) -- (6);
  \node at (6, 3.5) {КСС 2};
  
  % КСС 3
  \node (7) at (0, 0) {7};
  \node (8) at (2, 0) {8};
  \draw (7) -- (8);
  \node at (1, -0.5) {КСС 3};
  
  % КСС 4
  \node (9) at (5, 0) {9};
  \node (10) at (7, 0) {10};
  \node (11) at (6, -2) {11};
  \draw (9) -- (10) -- (11) -- (9);
  \node at (6, -2.5) {КСС 4};
  
  % КСС 5
  \node (12) at (9, 0) {12};
  \node (13) at (11, 0) {13};
  \node (14) at (10, -2) {14};
  \draw (12) -- (13) -- (14) -- (12);
  \node at (10, -2.5) {КСС 5};
  
  % КСС 6
  \node (1-6) at (2, -4) {1};
  \node (5-6) at (6, -4) {5};
  \node (9-6) at (10, -4) {9};
  \draw (1-6) -- (5-6) -- (9-6);
  \node at (6, -4.5) {КСС 6};
  
  % Раскраска вершин
  \foreach \i in {1, 2, 3, 4, 1-6} {
    \node[fill=blue!30] at (\i) {};
  }
  
  \foreach \i in {5, 6, 5-6} {
    \node[fill=red!30] at (\i) {};
  }
  
  \foreach \i in {7, 8} {
    \node[fill=green!30] at (\i) {};
  }
  
  \foreach \i in {9, 10, 11, 9-6} {
    \node[fill=orange!30] at (\i) {};
  }
  
  \foreach \i in {12, 13, 14} {
    \node[fill=purple!30] at (\i) {};
  }
  
  
\end{tikzpicture}
\end{center}

В данном графе мы выделили шесть различных компонент связности (КСС):
\begin{enumerate}
\item КСС 1: Вершины 1, 2, 3 и 4 образуют цикл и раскрашены синим цветом.
\item КСС 2: Вершины 5 и 6 соединены между собой и раскрашены красным цветом.
\item КСС 3: Вершины 7 и 8 соединены между собой и раскрашены зелёным цветом.
\item КСС 4: Вершины 9, 10 и 11 образуют цикл и раскрашены оранжевым цветом.
\item КСС 5: Вершины 12, 13 и 14 образуют цикл и раскрашены фиолетовым цветом.
\item КСС 6: Вершины 1, 5 и 9 соединены друг с другом и раскрашены синим, красным и оранжевым цветами соответственно, так как они являются частью уже выделенных компонентов.
\end{enumerate}
Таким образом, мы наглядно продемонстрировали выделение компонент связности в графе и их раскраску для лучшего понимания.
\end{document}
